name: CI/CD Pipeline

on:
  push:
    branches:
      - cicd-pipelines  # Trigger on pushes to the specified branch

jobs:
  build-Test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERTOKEN }}

      - name: Set Environment Variables
        run: |
          echo "IMAGE_NAME=yuvalbenar/flasksqlgifbase" >> $GITHUB_ENV
          echo "IMAGE_TAG=v1.0.83" >> $GITHUB_ENV
          echo "FLASK_ENV=${{ secrets.FLASK_ENV }}" >> $GITHUB_ENV
          echo "MYSQL_HOST=${{ secrets.DATABASE_HOST }}" >> $GITHUB_ENV
          echo "MYSQL_USER=${{ secrets.DATABASE_USER }}" >> $GITHUB_ENV
          echo "MYSQL_DATABASE=${{ secrets.DATABASE_NAME }}" >> $GITHUB_ENV
          echo "PORT=${{ secrets.PORT }}" >> $GITHUB_ENV
          echo "MYSQL_PASSWORD=${{ secrets.DATABASE_PASSWORD }}" >> $GITHUB_ENV
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> $GITHUB_ENV

      - name: Generate .env File
        run: |
          echo "IMAGE_NAME=yuvalbenar/flasksqlgifbase" > .env
          echo "IMAGE_TAG=v1.0.83" >> .env
          echo "FLASK_ENV=${{ secrets.FLASK_ENV }}" >> .env
          echo "MYSQL_HOST=${{ secrets.DATABASE_HOST }}" >> .env
          echo "MYSQL_USER=${{ secrets.DATABASE_USER }}" >> .env
          echo "MYSQL_DATABASE=${{ secrets.DATABASE_NAME }}" >> .env
          echo "PORT=${{ secrets.PORT }}" >> .env
          echo "MYSQL_PASSWORD=${{ secrets.DATABASE_PASSWORD }}" >> .env
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
        working-directory: /home/runner/work/terraflaskql/terraflaskql

      - name: Verify File Placement
        run: |
          ls -la
          cat .env
        working-directory: /home/runner/work/terraflaskql/terraflaskql

      - name: Build and Tag Docker Image
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
          docker tag ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} ${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.IMAGE_NAME }}:latest

      - name: Build and Test with Docker Compose
        run: |
          ls
          docker compose build --no-cache
          docker compose up -d
          sleep 5
          docker compose ps

      - name: Run Docker Compose
        run: |
          docker compose up -d
        working-directory: /home/runner/work/terraflaskql/terraflaskql

      - name: Test Application
        run: |
          docker compose logs
          curl -f http://localhost:${{ secrets.PORT }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-Test
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy EC2 Instance
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
            --region us-east-1 \
            --image-id ami-01816d07b1128cd2d \
            --instance-type t2.micro \
            --key-name ${{ secrets.EC2_KEY_NAME }} \
            --security-groups flask-mysql \
            --iam-instance-profile Name=access-to-s3 \
            --user-data '#!/bin/bash
            yum update -y
            yum install -y docker
            systemctl start docker
            systemctl enable docker
            usermod -aG docker ec2-user
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose' \
            --query 'Instances[0].InstanceId' \
            --output text)

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

      - name: Wait for SSH Access
        run: |
          while ! nc -z ${{ env.PUBLIC_IP }} 22; do
            echo "Waiting for SSH..."
            sleep 5
          done

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Generate .env File
        run: |
          echo "IMAGE_NAME=${{ env.IMAGE_NAME }}" > .env
          echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> .env
          echo "FLASK_ENV=${{ secrets.FLASK_ENV }}" >> .env
          echo "MYSQL_HOST=${{ secrets.DATABASE_HOST }}" >> .env
          echo "MYSQL_USER=${{ secrets.DATABASE_USER }}" >> .env
          echo "MYSQL_DATABASE=${{ secrets.DATABASE_NAME }}" >> .env
          echo "PORT=${{ secrets.PORT }}" >> .env
          echo "MYSQL_PASSWORD=${{ secrets.DATABASE_PASSWORD }}" >> .env
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env

      - name: Copy Files to EC2
        run: |
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            docker-compose.yaml .env \
            ec2-user@${{ env.PUBLIC_IP }}:/home/ec2-user/

      - name: Run Application on EC2
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ec2-user@${{ env.PUBLIC_IP }} << EOF
            cd /home/ec2-user
            docker-compose up -d --quiet-pull
            >> EOF
